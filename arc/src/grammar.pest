WHITESPACE        = _{ " " | "\n" | "\r" }
COMMENT           = _{ SingleLineComment | MultiLineComment }
SingleLineComment = @{ "//" ~ (!"\n" ~ ANY)* }
MultiLineComment  = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

IDENT_CHARS =  { ASCII_ALPHANUMERIC | "_" }
IDENTIFIER  = @{ !(KEYWORD ~ !ASCII_ALPHANUMERIC) ~ (ASCII_ALPHA ~ IDENT_CHARS* | ("_" ~ IDENT_CHARS+)) }
KEYWORD     =  {
    a_fx
  | a_let
  | a_mut
  | a_as
  | a_import
  | a_pub
  | a_mod
  | a_super
  | a_self
  | a_if
  | a_else
  | a_while
  | a_for
  | a_in
  | a_continue
  | a_break
  | a_match
  | a_impl
  | a_struct
  | a_enum
  | a_return
  | a_result
  | a_ok
  | a_err
  | a_type
  | TYPE
}

a_fx        = _{ "fx" }
a_tilde     = _{ "~" }
a_let       =  { "let" }
a_mut       =  { "mut" }
a_import    =  { "import" }
a_pub       =  { "pub" }
a_mod       =  { "mod" }
a_super     =  { "super" }
a_self      =  { "self" }
a_if        =  { "if" }
a_else      =  { "else" }
a_while     =  { "while" }
a_for       =  { "for" }
a_in        =  { "in" }
a_continue  =  { "continue" }
a_break     =  { "break" }
a_match     =  { "match" }
a_fat_arrow =  { "=>" }
a_return    =  { "return" }
a_result    =  { "result" }
a_ok        =  { "ok" }
a_err       =  { "err" }
a_type      =  { "type" }
a_as        =  { "as" }
a_struct    =  { "struct" }
a_enum      =  { "enum" }
a_impl      =  { "impl" }

INTEGER = @{ ("-" | "0b" | "0o" | "0x")? ~ ("_")? ~ ASCII_DIGIT ~ (ASCII_DIGIT | "_")* }
FLOAT   = @{ INTEGER ~ "." ~ ASCII_DIGIT* }
BOOL    = @{ "true" | "false" }

STRING = @{ "\"" ~ (!("\"") ~ ANY)* ~ "\"" }
CHAR   = @{ "'" ~ ANY ~ "'" }
// CHAR = @{"'" ~ (!("'") ~ ASCII_ALPHA) ~ "'" }

TUPLE = { "(" ~ (EXPRESSION ~ ("," ~ EXPRESSION)*)? ~ ")" }
ARRAY = { "[" ~ (EXPRESSION ~ ("," ~ EXPRESSION)*)? ~ "]" }
LIST  = { "<" ~ (EXPRESSION ~ ("," ~ EXPRESSION)*)? ~ ">" }

DATA_TYPES = { TUPLE | ARRAY | LIST | FLOAT | INTEGER | STRING | CHAR | BOOL | IDENTIFIER }

TYPE        = { TUPLE_TYPE | ARRAY_TYPE | LIST_TYPE | RESULT_TYPE | "i32" | "i64" | "f32" | "f64" | "char" | "bool" }
TUPLE_TYPE  = { "(" ~ (TYPE ~ ("," ~ TYPE)*)? ~ ")" }
ARRAY_TYPE  = { "[" ~ TYPE ~ ";" ~ INTEGER ~ "]" }
LIST_TYPE   = { "<" ~ TYPE ~ ">" }
RESULT_TYPE = { ("result<" | "Result<") ~ (TYPE | IDENTIFIER) ~ "," ~ (TYPE | IDENTIFIER) ~ ">" }

OPERATOR = {
    OPERATOR_LEVEL_1
  | OPERATOR_LEVEL_2
  | OPERATOR_LEVEL_3
  | OPERATOR_LEVEL_4
  | OPERATOR_LEVEL_5
  | OPERATOR_LEVEL_6
  | OPERATOR_LEVEL_7
  | OPERATOR_LEVEL_8
  | OPERATOR_LEVEL_9
  | OPERATOR_LEVEL_10
}

OPERATOR_LEVEL_1  = { multiply | divide | remainder }
OPERATOR_LEVEL_2  = { add | subtract }
OPERATOR_LEVEL_3  = { bitwise_shift }
OPERATOR_LEVEL_4  = { bitwise_and }
OPERATOR_LEVEL_5  = { bitwise_xor }
OPERATOR_LEVEL_6  = { bitwise_or }
OPERATOR_LEVEL_7  = { logical_and }
OPERATOR_LEVEL_8  = { logical_or }
OPERATOR_LEVEL_9  = { comparison }
OPERATOR_LEVEL_10 = { ASSIGNMENT }

multiply           = { "*" }
divide             = { "/" }
remainder          = { "%" }
add                = { "+" }
subtract           = { "-" }
unary_plus         = { "++" }
unary_minus        = { "--" }
logical_and        = { "&&" }
logical_or         = { "||" }
logical_not        = { "!" }
comparison         = { equal | not_equal | greater_than_equal | less_than_equal | greater_than | less_than }
equal              = { "==" }
not_equal          = { "!=" }
greater_than_equal = { ">=" }
less_than_equal    = { "<=" }
greater_than       = { ">" }
less_than          = { "<" }

ASSIGNMENT                 = { assign | plus_assign | minus_assign | multiply_assign | divide_assign | remainder_assign | bitwise_and_assign | bitwise_or_assign | bitwise_xor_assign | bitwise_left_shift_assign | bitwise_right_shift_assign }
assign                     = { "=" }
plus_assign                = { "+=" }
minus_assign               = { "-=" }
multiply_assign            = { "*=" }
divide_assign              = { "/=" }
remainder_assign           = { "%=" }
bitwise_and_assign         = { "&=" }
bitwise_or_assign          = { "|=" }
bitwise_xor_assign         = { "^=" }
bitwise_left_shift_assign  = { "<<=" }
bitwise_right_shift_assign = { ">>=" }

bitwise_shift = { left_shift | right_shift }
bitwise_not   = { "!" }
bitwise_and   = { "&" }
bitwise_xor   = { "^" }
bitwise_or    = { "|" }
left_shift    = { "<<" }
right_shift   = { ">>" }

STATEMENT = {
    a_let? ~ a_mut? ~ IDENTIFIER ~ TYPE? ~ ASSIGNMENT ~ (CLOSURE | FUNCTION_CALL | MODULE_ACCESS | IF_STATEMENT | MATCH_STATEMENT | EXPRESSION | EXP_BLOCK) ~ ";"
  | (FUNCTION_CALL | IMPL_ACCESS | MODULE_ACCESS) ~ ";"
  | BREAK_STMT
  | IF_STATEMENT
  | MATCH_STATEMENT
  | FOR_LOOP
  | WHILE_LOOP
}

BREAK_STMT = { a_break ~ ";" }

IF_STATEMENT      = { "if" ~ EXPRESSION ~ EXP_BLOCK ~ ELSE_IF_STATEMENT* ~ ELSE_BLOCK? }
ELSE_IF_STATEMENT = { "else" ~ "if" ~ EXPRESSION ~ EXP_BLOCK }
ELSE_BLOCK        = { "else" ~ EXP_BLOCK }

EXP_BLOCK = { "{" ~ STATEMENT* ~ (EXPRESSION | RETURN_STMT)? ~ "}" }
BLOCK     = { "{" ~ STATEMENT* ~ (RETURN_STMT)? ~ "}" }

MATCH_STATEMENT = { "match" ~ EXPRESSION ~ "{" ~ MATCH_CASE* ~ MATCH_DEFAULT? ~ "}" }
MATCH_CASE      = { EXPRESSION ~ a_fat_arrow ~ EXPRESSION ~ "," }
MATCH_DEFAULT   = { "_" ~ a_fat_arrow ~ EXPRESSION ~ "," }

FOR_LOOP = { "for" ~ IDENTIFIER ~ "in" ~ RANGE ~ BLOCK }
RANGE    = { EXPRESSION ~ ".." ~ EXPRESSION }

WHILE_LOOP = { "while" ~ EXPRESSION ~ BLOCK }

// EXPRESSION = { TERM ~ (("+" | "-") ~ TERM)* }
// TERM       = { FACTOR ~ (("*" | "/") ~ FACTOR)* }
EXPRESSION = { FACTOR ~ (OPERATOR ~ FACTOR)* }
FACTOR     = {
    (bitwise_not | subtract)? ~ (TUPLE_ACCESS | ARRAY_ACCESS | LIST_ACCESS | IMPL_ACCESS | MODULE_ACCESS | STRUCT_ENUM_ACCESS | FUNCTION_CALL | ERROR_CHECK | DATA_TYPES ~ (a_as ~ TYPE)? | ("(" ~ EXPRESSION ~ ")"))
}

TUPLE_ACCESS       = { IDENTIFIER ~ "." ~ INTEGER }
ARRAY_ACCESS       = { IDENTIFIER ~ "[" ~ (IDENTIFIER | INTEGER) ~ "]" }
LIST_ACCESS        = { IDENTIFIER ~ "[" ~ (IDENTIFIER | INTEGER) ~ "]" }
IMPL_ACCESS        = { IDENTIFIER ~ "." ~ FUNCTION_CALL }
STRUCT_ENUM_ACCESS = { (IDENTIFIER | a_self) ~ "." ~ IDENTIFIER }

FUNCTION_DECLARATION = { a_pub? ~ a_fx ~ IDENTIFIER ~ PARAMETER_LIST ~ RETURN_TYPE? ~ FUNCTION_BODY }
PARAMETER_LIST       = { "(" ~ (PARAMETER ~ ("," ~ PARAMETER)*)* ~ ")" }
PARAMETER            = { (bitwise_and ~ a_self) | (IDENTIFIER ~ (TYPE | IDENTIFIER)) }
RETURN_TYPE          = { a_tilde ~ TYPE }
RETURN_STMT          = { "return" ~ EXPRESSION ~ ";" }
FUNCTION_BODY        = { "{" ~ STATEMENT* ~ RETURN_STMT? ~ "}" }

FUNCTION_CALL  = { (IDENTIFIER | a_err | a_ok) ~ ARGUMENTS_LIST }
ARGUMENTS_LIST = { "(" ~ (ARGUMENT ~ ("," ~ ARGUMENT)*)? ~ ")" }
ARGUMENT       = { bitwise_and? ~ EXPRESSION }

ERROR_CHECK = { a_let ~ (a_ok | a_err) ~ ARGUMENTS_LIST }

CLOSURE = { "fx" ~ ARGUMENTS_LIST ~ RETURN_TYPE? ~ EXP_BLOCK }

MODULE_DECLARATION = { a_pub? ~ a_mod ~ IDENTIFIER ~ MODULE_BLOCK }
MODULE_BLOCK       = { "{" ~ PROGRAM_BLOCK ~ "}" }
MODULE_ACCESS      = { IDENTIFIER ~ "::" ~ (FUNCTION_CALL | (IDENTIFIER ~ ("::" ~ IDENTIFIER)* ~ ("::" ~ FUNCTION_CALL)?)) }

IMPORT_STMT       = { a_import ~ IMPORT_IDENTIFIER ~ ("::" ~ IMPORT_IDENTIFIER)* ~ ("::" ~ multiply)? ~ ";" }
IMPORT_IDENTIFIER = { a_self | a_super | IDENTIFIER }

STRUCT_BLOCK = { a_struct ~ IDENTIFIER ~ "{" ~ STRUCT_FIELD* ~ "}" }
STRUCT_FIELD = { IDENTIFIER ~ ":" ~ (TYPE | IDENTIFIER) ~ "," }

ENUM_BLOCK   = { a_enum ~ IDENTIFIER ~ "{" ~ ENUM_VARIANT* ~ "}" }
ENUM_VARIANT = { IDENTIFIER ~ ("(" ~ (TYPE | IDENTIFIER) ~ ")")? ~ "," }

IMPL_BLOCK  = { a_impl ~ IDENTIFIER ~ "{" ~ IMPL_METHOD* ~ "}" }
IMPL_METHOD = { FUNCTION_DECLARATION }

PROGRAM_BLOCK = { (IMPORT_STMT | MODULE_DECLARATION | STRUCT_BLOCK | ENUM_BLOCK | IMPL_BLOCK | FUNCTION_DECLARATION)* }
PROGRAM       = { SOI ~ NEWLINE* ~ PROGRAM_BLOCK ~ NEWLINE* ~ EOI }
