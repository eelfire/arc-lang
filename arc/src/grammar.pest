WHITESPACE        = _{ " " | "\n" }
COMMENT           = _{ SingleLineComment | MultiLineComment }
SingleLineComment = @{ "//" ~ (!"\n" ~ ANY)* }
MultiLineComment  = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

IDENTIFIER = @{ !KEYWORD ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
// KEYWORD    = @{ "fx" | "let" | "mut" | "as" | TYPE | "import" | "pub" | "mod" | "super" | "self" | "if" | "else" | "else if" | "while" | "for" | "in" | "continue" | "break" | "match" | "impl" | "struct" | "enum" }
KEYWORD     =  {
    a_fx
  | a_let
  | a_mut
  | a_as
  | a_import
  | a_pub
  | a_mod
  | a_super
  | a_self
  | a_if
  | a_else
  | a_while
  | a_for
  | a_in
  | a_continue
  | a_break
  | a_match
  | a_impl
  | a_struct
  | a_enum
  | a_return
  | a_result
  | a_ok
  | a_err
  | a_type
  | TYPE
}
a_fx        = _{ "fx" }
a_tilde     = _{ "~" }
a_let       =  { "let" }
a_mut       =  { "mut" }
a_import    =  { "import" }
a_pub       =  { "pub" }
a_mod       =  { "mod" }
a_super     =  { "super" }
a_self      =  { "self" }
a_if        =  { "if" }
a_else      =  { "else" }
a_while     =  { "while" }
a_for       =  { "for" }
a_in        =  { "in" }
a_continue  =  { "continue" }
a_break     =  { "break" }
a_match     =  { "match" }
a_fat_arrow =  { "=>" }
a_return    =  { "return" }
a_result    =  { "result" }
a_ok        =  { "ok" }
a_err       =  { "err" }
a_type      =  { "type" }
a_as        =  { "as" }
a_struct    =  { "struct" }
a_enum      =  { "enum" }
a_impl      =  { "impl" }

INTEGER = @{ ("-")? ~ ASCII_DIGIT+ }
FLOAT   = @{ INTEGER ~ "." ~ ASCII_DIGIT* }
BOOL    = @{ "true" | "false" }

STRING = @{ "\"" ~ (!("\"") ~ ANY)* ~ "\"" }
CHAR   = @{ "'" ~ ANY ~ "'" }
// CHAR = @{"'" ~ (!("'") ~ ASCII_ALPHA) ~ "'" }

TUPLE = { "(" ~ (EXPRESSION ~ ("," ~ EXPRESSION)*)? ~ ")" }
ARRAY = { "[" ~ (EXPRESSION ~ ("," ~ EXPRESSION)*)? ~ "]" }
LIST  = { "<" ~ (EXPRESSION ~ ("," ~ EXPRESSION)*)? ~ ">" }

DATA_TYPES = { TUPLE | ARRAY | LIST | FLOAT | INTEGER | STRING | CHAR | BOOL | IDENTIFIER }

TYPE       = { TUPLE_TYPE | ARRAY_TYPE | LIST_TYPE | "i32" | "i64" | "f32" | "f64" | "char" | "bool" }
TUPLE_TYPE = { "(" ~ (TYPE ~ ("," ~ TYPE)*)? ~ ")" }
ARRAY_TYPE = { "[" ~ TYPE ~ ";" ~ INTEGER ~ "]" }
LIST_TYPE  = { "<" ~ TYPE ~ ">" }

OPERATOR = {
    OPERATOR_LEVEL_1
  | OPERATOR_LEVEL_2
  | OPERATOR_LEVEL_3
  | OPERATOR_LEVEL_4
  | OPERATOR_LEVEL_5
  | OPERATOR_LEVEL_6
  | OPERATOR_LEVEL_7
  | OPERATOR_LEVEL_8
  | OPERATOR_LEVEL_9
  | OPERATOR_LEVEL_10
}

OPERATOR_LEVEL_1  = { multiply | divide | remainder }
OPERATOR_LEVEL_2  = { add | subtract }
OPERATOR_LEVEL_3  = { bitwise_shift }
OPERATOR_LEVEL_4  = { bitwise_and }
OPERATOR_LEVEL_5  = { bitwise_xor }
OPERATOR_LEVEL_6  = { bitwise_or }
OPERATOR_LEVEL_7  = { logical_and }
OPERATOR_LEVEL_8  = { logical_or }
OPERATOR_LEVEL_9  = { comparison }
OPERATOR_LEVEL_10 = { ASSIGNMENT }

multiply           = { "*" }
divide             = { "/" }
remainder          = { "%" }
add                = { "+" }
subtract           = { "-" }
bitwise_shift      = { left_shift | right_shift }
bitwise_and        = { "&" }
bitwise_xor        = { "^" }
bitwise_or         = { "|" }
logical_and        = { "&&" }
logical_or         = { "||" }
comparison         = { equal | not_equal | greater_than_equal | less_than_equal | greater_than | less_than }
equal              = { "==" }
not_equal          = { "!=" }
greater_than_equal = { ">=" }
less_than_equal    = { "<=" }
greater_than       = { ">" }
less_than          = { "<" }
ASSIGNMENT         = { assign | plus_assign | minus_assign | multiply_assign | divide_assign | remainder_assign }

left_shift       = { "<<" }
right_shift      = { ">>" }
assign           = { "=" }
plus_assign      = { "+=" }
minus_assign     = { "-=" }
multiply_assign  = { "*=" }
divide_assign    = { "/=" }
remainder_assign = { "%=" }

STATEMENT = {
    a_let? ~ a_mut? ~ IDENTIFIER ~ TYPE? ~ ASSIGNMENT ~ (CLOSURE | FUNCTION_CALL | EXPRESSION) ~ ";"
  | (FUNCTION_CALL | IMPL_ACCESS) ~ ";"
  | IF_STATEMENT
  | MATCH_STATEMENT
  | FOR_LOOP
  | WHILE_LOOP
}

IF_STATEMENT = {
    "if" ~ EXPRESSION ~ BLOCK ~ ELSE_IF_STATEMENT* ~ ELSE_BLOCK?
}

ELSE_IF_STATEMENT = {
    "else" ~ "if" ~ EXPRESSION ~ BLOCK
}

ELSE_BLOCK = {
    "else" ~ BLOCK
}

BLOCK = {
    "{" ~ STATEMENT* ~ "}"
}

MATCH_STATEMENT = {
    "match" ~ EXPRESSION ~ "{" ~ MATCH_CASE* ~ "}"
}

MATCH_CASE = {
    EXPRESSION ~ "=>" ~ EXPRESSION ~ ","
}

FOR_LOOP = {
    "for" ~ IDENTIFIER ~ "in" ~ RANGE ~ BLOCK
}

RANGE = {
    EXPRESSION ~ ".." ~ EXPRESSION
}

WHILE_LOOP = {
    "while" ~ EXPRESSION ~ BLOCK
}

// EXPRESSION = { TERM ~ (("+" | "-") ~ TERM)* }
// TERM       = { FACTOR ~ (("*" | "/") ~ FACTOR)* }
EXPRESSION = { FACTOR ~ (OPERATOR ~ FACTOR)* }
FACTOR     = {
    TUPLE_ACCESS
  | ARRAY_ACCESS
  | LIST_ACCESS
  | IMPL_ACCESS
  | DATA_TYPES ~ (a_as ~ TYPE)?
  | ("(" ~ EXPRESSION ~ ")")
}

/*
    let a = match a {
    1 => 1,
    2 => 2,
    _ => 3
    }

    let b = if a == 1 {
    1
    } else if a == 2 {
    2
    } else {
    3
    }

    let mut c = 0;
    if a > b {
    c = a;
    } else {
    c = b;
*/

TUPLE_ACCESS = { IDENTIFIER ~ "." ~ INTEGER }
ARRAY_ACCESS = { IDENTIFIER ~ "[" ~ (IDENTIFIER | INTEGER) ~ "]" }
LIST_ACCESS  = { IDENTIFIER ~ "[" ~ (IDENTIFIER | INTEGER) ~ "]" }
IMPL_ACCESS  = { IDENTIFIER ~ "." ~ FUNCTION_CALL }

FUNCTION_DECLARATION = { a_fx ~ IDENTIFIER ~ PARAMETER_LIST ~ RETURN_TYPE? ~ FUNCTION_BODY }
PARAMETER_LIST       = { "(" ~ (PARAMETER ~ ("," ~ PARAMETER)*)* ~ ")" }
PARAMETER            = { IDENTIFIER ~ TYPE }
RETURN_TYPE          = { a_tilde ~ TYPE }
RETURN_STMT          = { "return" ~ EXPRESSION ~ ";" }
FUNCTION_BODY        = { "{" ~ STATEMENT* ~ RETURN_STMT? ~ "}" }

FUNCTION_CALL  = { IDENTIFIER ~ ARGUMENTS_LIST }
ARGUMENTS_LIST = { "(" ~ (ARGUMENT ~ ("," ~ ARGUMENT)*)? ~ ")" }
ARGUMENT       = { EXPRESSION }

CLOSURE = { "fx" ~ ARGUMENTS_LIST ~ RETURN_TYPE? ~ FUNCTION_BODY }

PROGRAM = { SOI ~ NEWLINE* ~ FUNCTION_DECLARATION* ~ NEWLINE* ~ EOI }
